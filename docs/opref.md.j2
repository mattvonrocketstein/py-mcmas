{% import 'macros/base.j2' as macros -%}{% import 'macros/site.j2' as site -%}

## Reference for Logics and operators
<hr style="width:100%;border-bottom:3px solid black;">

{% include "admonition/generated.md.j2"%}

{#

Temporal, Epistemic, and Strategic Logic Operators Reference
#}

### Path Quantifiers
<hr style="width:100%;border-bottom:3px solid black;">

<a href=https://en.wikipedia.org/wiki/Quantifier_(logic)s><i>Path Quantifiers</i></a>, or first-order logic

{%for x in 'a e'.split()%}<a id='{{x}}'></a>{%endfor%}
<table class=docutils-wrap >
<thead><tr><th>Syntax</th><th>Operator</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>A(φ)</td>
<td>All paths</td>
<td>φ holds on all computation paths</td>
</tr>
<tr>
<td>E(φ)</td>
<td>Exists path</td>
<td class=wrap>φ holds on at least one computation path</td>
</tr>
</table>

### Temporal Operators
<hr style="width:100%;border-bottom:3px solid black;">

<a href=https://en.wikipedia.org/wiki/Temporal_logic#Temporal_operators></i>Temporal Logic</i></a>, or **TL**.

{%for x in 'x f g u'.split()%}<a id='{{x}}'></a>{%endfor%}
<table class=docutils-wrap >
<thead><tr><th>Syntax</th><th>Operator</th><th>Description</th></tr></thead>
<tr>
<td>X(φ)</td>
<td>Next</td>
<td class=wrap>φ holds in the next state</td>
</tr>
<tr>
<td>F(φ)</td>
<td>Future/Finally</td>
<td class=wrap>φ will eventually hold</td>
</tr>
<td>Globally/Always</td>
<td>G(φ)</td>
<td class=wrap>φ holds continuously</td>
</tr>
<tr>
<td>U(φ)</td>
<td>Until</td>
<td class=wrap>φ holds until another property is true</td>
</tr>
<tr>
</table>

### Computation Tree Logic
<hr style="width:100%;border-bottom:3px solid black;">

**Computation Tree Logic (CTL)** extends propositional logic with path quantifiers (A, E) combined with temporal operators (X, F, G, U) to reason about branching time structures.  One extension is PCTL (Probabilitstic CTL), used in PRISM[^1]

<a href=https://en.wikipedia.org/wiki/Computation_tree_logic#Operators></i>Computation Tree Logic</i></a>, or **CTL**.

{%for x in 'ag ef ax af eg'.split()%}<a id='{{x}}'></a>{%endfor%}
<table class=docutils-wrap >
<thead><tr><th>Syntax</th><th>Operator</th><th>Description</th></tr></thead>
<tr>
<td>AG(φ)</td>
<td>Always globally</td>
<td class=wrap>φ holds globally on all paths <br>(φ is always true)</td>
</tr>
<tr>
<td>EF(φ)</td>
<td>Eventually possible</td>
<td class=wrap>φ eventually holds on some path <br>(φ is possibly true)</td>
</tr>
<tr>
<td>AX(φ)</td>
<td>Next on all paths</td>
<td class=wrap>φ holds in the next state on all paths</td>
</tr>
<tr>
<td>AF(φ)</td>
<td>Always eventually</td>
<td class=wrap>φ eventually holds on all paths <br>(φ is inevitable)</td>
</tr>
<tr>
<td>EG(φ)</td>
<td>Possibly always</td>
<td class=wrap>φ holds globally on some path<br>(φ can remain true forever)</td>
</tr>
</tbody>
</table>

### Dynamic Epistemic Logic
<hr style="width:100%;border-bottom:3px solid black;">

<a href=https://en.wikipedia.org/wiki/Dynamic_epistemic_logic#Syntax><i>Dynamic Epistemic Logic</i></a>, or **DEL**.

**Epistemic Logic** formalizes reasoning about knowledge and belief, where the basic knowledge operator K(i, φ) satisfies axioms like: if K(i, φ) then φ (knowledge implies truth).

**Common Knowledge** (GCK) is particularly important as it represents infinite mutual knowledge - not only does everyone know φ, but everyone knows that everyone knows φ, recursively.

{%for x in 'k gk gck dk'.split()%}<a id='{{x}}'></a>{%endfor%}
<table class=docutils-wrap >
<thead><tr><th>Syntax</th><th>Operator</th><th>Description</th></tr></thead>
</thead>
<tbody>
<tr>
<td>K(i, φ)</td>
<td>Knowledge</td>
<td class=wrap>Agent i knows proposition φ</td>
</tr>
<tr>
<td>GK(G, φ)</td>
<td>Group Knowledge</td>
<td class=wrap>Every agent in group G knows φ</td>
</tr>
<tr>
<td>GCK(G, φ)</td>
<td>General Common Knowledge</td>
<td class=wrap>Common knowledge among group G that φ <br>(everyone knows, everyone knows that everyone knows, etc. infinitely)</td>
</tr>
<tr>
<td>DK(G, φ)</td>
<td>Distributed Knowledge</td>
<td class=wrap>Group G collectively has enough information to deduce φ,<br> even if no individual agent knows φ</td>
</tr>
</tbody>
</table>

### Strategic Logic
<hr style="width:100%;border-bottom:3px solid black;">

<a href=https://en.wikipedia.org/wiki/Alternating-time_temporal_logic><i>(Alternating-time temporal logic)</i> </a>, or **ATL**

**Alternating-time Temporal Logic (ATL)** quantifies over strategies rather than just paths, allowing coalitions to guarantee outcomes regardless of opponents' actions.

{%for x in 'k gk gck dk'.split()%}<a id='{{x}}'></a>{%endfor%}
<table class=docutils-wrap >
<thead><tr><th>Syntax</th><th>Operator</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>&lt;group1&gt;F(φ)</td>
<td>Strategic Eventually</td>
<td class=wrap>The coalition "Group" has a strategy to eventually make φ true</td>
</tr>
<tr>
<td>&lt;group1&gt;G(φ)</td>
<td>Strategic Always</td>
<td>The coalition can maintain φ forever</td>
</tr>
<tr>
<td>&lt;group1&gt;X(φ)</td>
<td>Strategic Next</td>
<td>The coalition can make φ true in the next step</td>
</tr>
</tbody>
</table>


### Obligation Logic
<hr style="width:100%;border-bottom:3px solid black;">

<a href=https://en.wikipedia.org/wiki/Dynamic_epistemic_logic#Syntax><i>Deontic Logic</i></a>, aka DL, deals with obligations or "colors".

{%for x in 'o'.split()%}<a id='{{x}}'></a>{%endfor%}
<table class=docutils-wrap >
<thead><tr><th>Operator</th><th>Syntax</th><th>Description</th></tr></thead>
<tr>
<td>O(φ)</td>
<td>Obligation</td>
<td class=wrap>φ is an obligation<br/>
</td>
</tr>
<tr>
</table>

Since partitioning predicates as either "obliged" or "permissible" is a simple enrichment to true/false, there's lots of ways to frame this and interpret it.  
ISPL calls this "RedStates" and "GreenStates", and introduces reserved keywords for *each Agent* to express more complex requirements.

### References
<hr style="width:100%;border-bottom:3px solid black;">

[^1]: [claude://ba29d757-ba5e-45c7-992e-971da71b6d30](https://claude.ai/public/artifacts/ba29d757-ba5e-45c7-992e-971da71b6d30)
[^2]: Official [User Manual]({{jinja.vars.mcmas_manual}}), Section 3.2  (pdf)
[^3]: [See all references from all pages]({{mkdocs.site_relative_url}}/refs)
[^4]: For the ISPL grammar, see [User Manual]({{jinja.vars.mcmas_manual}}), Section 3.4 (pdf)

{#
#}